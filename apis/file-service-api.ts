/* tslint:disable */
/* eslint-disable */
/**
 * Apache OpenMeetings API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 7.0.0-SNAPSHOT
 * Contact: dev@openmeetings.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { FileExplorerObject } from '../models';
import { FileItemDTO } from '../models';
import { ServiceResult } from '../models';
/**
 * FileServiceApi - axios parameter creator
 * @export
 */
export const FileServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * to add a folder to the private drive, set parentId = 0 and isOwner to 1/true and  externalUserId/externalUserType to a valid USER
         * @param {string} externalId 
         * @param {string} externalType 
         * @param {number} groupId 
         * @param {string} hash 
         * @param {number} height 
         * @param {number} id 
         * @param {string} name 
         * @param {number} ownerId 
         * @param {number} parentId 
         * @param {number} roomId 
         * @param {number} size 
         * @param {string} type 
         * @param {number} width 
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add: async (externalId: string, externalType: string, groupId: number, hash: string, height: number, id: number, name: string, ownerId: number, parentId: number, roomId: number, size: number, type: string, width: number, sid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalId' is not null or undefined
            if (externalId === null || externalId === undefined) {
                throw new RequiredError('externalId','Required parameter externalId was null or undefined when calling add.');
            }
            // verify required parameter 'externalType' is not null or undefined
            if (externalType === null || externalType === undefined) {
                throw new RequiredError('externalType','Required parameter externalType was null or undefined when calling add.');
            }
            // verify required parameter 'groupId' is not null or undefined
            if (groupId === null || groupId === undefined) {
                throw new RequiredError('groupId','Required parameter groupId was null or undefined when calling add.');
            }
            // verify required parameter 'hash' is not null or undefined
            if (hash === null || hash === undefined) {
                throw new RequiredError('hash','Required parameter hash was null or undefined when calling add.');
            }
            // verify required parameter 'height' is not null or undefined
            if (height === null || height === undefined) {
                throw new RequiredError('height','Required parameter height was null or undefined when calling add.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling add.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling add.');
            }
            // verify required parameter 'ownerId' is not null or undefined
            if (ownerId === null || ownerId === undefined) {
                throw new RequiredError('ownerId','Required parameter ownerId was null or undefined when calling add.');
            }
            // verify required parameter 'parentId' is not null or undefined
            if (parentId === null || parentId === undefined) {
                throw new RequiredError('parentId','Required parameter parentId was null or undefined when calling add.');
            }
            // verify required parameter 'roomId' is not null or undefined
            if (roomId === null || roomId === undefined) {
                throw new RequiredError('roomId','Required parameter roomId was null or undefined when calling add.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling add.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling add.');
            }
            // verify required parameter 'width' is not null or undefined
            if (width === null || width === undefined) {
                throw new RequiredError('width','Required parameter width was null or undefined when calling add.');
            }
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling add.');
            }
            const localVarPath = `/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }


            if (externalId !== undefined) { 
                localVarFormParams.append('externalId', externalId as any);
            }

            if (externalType !== undefined) { 
                localVarFormParams.append('externalType', externalType as any);
            }

            if (groupId !== undefined) { 
                localVarFormParams.append('groupId', groupId as any);
            }

            if (hash !== undefined) { 
                localVarFormParams.append('hash', hash as any);
            }

            if (height !== undefined) { 
                localVarFormParams.append('height', height as any);
            }

            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }

            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (ownerId !== undefined) { 
                localVarFormParams.append('ownerId', ownerId as any);
            }

            if (parentId !== undefined) { 
                localVarFormParams.append('parentId', parentId as any);
            }

            if (roomId !== undefined) { 
                localVarFormParams.append('roomId', roomId as any);
            }

            if (size !== undefined) { 
                localVarFormParams.append('size', size as any);
            }

            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }

            if (width !== undefined) { 
                localVarFormParams.append('width', width as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * deletes files or folders based on it id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the id of the file or folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (sid: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling delete1.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete1.');
            }
            const localVarPath = `/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * deletes a file by its external Id and type
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} externaltype the externalType
         * @param {string} externalid the id of the file or folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExternal: async (sid: string, externaltype: string, externalid: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling deleteExternal.');
            }
            // verify required parameter 'externaltype' is not null or undefined
            if (externaltype === null || externaltype === undefined) {
                throw new RequiredError('externaltype','Required parameter externaltype was null or undefined when calling deleteExternal.');
            }
            // verify required parameter 'externalid' is not null or undefined
            if (externalid === null || externalid === undefined) {
                throw new RequiredError('externalid','Required parameter externalid was null or undefined when calling deleteExternal.');
            }
            const localVarPath = `/file/{externaltype}/{externalid}`
                .replace(`{${"externaltype"}}`, encodeURIComponent(String(externaltype)))
                .replace(`{${"externalid"}}`, encodeURIComponent(String(externalid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all files by external type
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} externaltype External type for file listing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExternal: async (sid: string, externaltype: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling getAllExternal.');
            }
            // verify required parameter 'externaltype' is not null or undefined
            if (externaltype === null || externaltype === undefined) {
                throw new RequiredError('externaltype','Required parameter externaltype was null or undefined when calling getAllExternal.');
            }
            const localVarPath = `/file/{externaltype}`
                .replace(`{${"externaltype"}}`, encodeURIComponent(String(externaltype)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a File Explorer Object by a given ROOM
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id ROOM Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoom: async (sid: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling getRoom.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoom.');
            }
            const localVarPath = `/file/room/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of FileItemDTO by parent
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the parent folder id
         * @param {number} parent the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomByParent: async (sid: string, id: number, parent: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling getRoomByParent.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoomByParent.');
            }
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling getRoomByParent.');
            }
            const localVarPath = `/file/room/{id}/{parent}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * move a file or folder
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id current file or folder id to be moved
         * @param {number} roomid room this file need to be moved
         * @param {number} parentid new parent folder id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move: async (sid: string, id: number, roomid: number, parentid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling move.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling move.');
            }
            // verify required parameter 'roomid' is not null or undefined
            if (roomid === null || roomid === undefined) {
                throw new RequiredError('roomid','Required parameter roomid was null or undefined when calling move.');
            }
            // verify required parameter 'parentid' is not null or undefined
            if (parentid === null || parentid === undefined) {
                throw new RequiredError('parentid','Required parameter parentid was null or undefined when calling move.');
            }
            const localVarPath = `/file/move/{roomid}/{id}/{parentid}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roomid"}}`, encodeURIComponent(String(roomid)))
                .replace(`{${"parentid"}}`, encodeURIComponent(String(parentid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * update a file or folder name
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id file or folder id
         * @param {string} name new file or folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename: async (sid: string, id: number, name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling rename.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling rename.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling rename.');
            }
            const localVarPath = `/file/rename/{id}/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileServiceApi - functional programming interface
 * @export
 */
export const FileServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * to add a folder to the private drive, set parentId = 0 and isOwner to 1/true and  externalUserId/externalUserType to a valid USER
         * @param {string} externalId 
         * @param {string} externalType 
         * @param {number} groupId 
         * @param {string} hash 
         * @param {number} height 
         * @param {number} id 
         * @param {string} name 
         * @param {number} ownerId 
         * @param {number} parentId 
         * @param {number} roomId 
         * @param {number} size 
         * @param {string} type 
         * @param {number} width 
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add(externalId: string, externalType: string, groupId: number, hash: string, height: number, id: number, name: string, ownerId: number, parentId: number, roomId: number, size: number, type: string, width: number, sid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileItemDTO>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).add(externalId, externalType, groupId, hash, height, id, name, ownerId, parentId, roomId, size, type, width, sid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * deletes files or folders based on it id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the id of the file or folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(sid: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).delete1(sid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * deletes a file by its external Id and type
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} externaltype the externalType
         * @param {string} externalid the id of the file or folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExternal(sid: string, externaltype: string, externalid: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).deleteExternal(sid, externaltype, externalid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get all files by external type
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} externaltype External type for file listing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllExternal(sid: string, externaltype: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileItemDTO>>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).getAllExternal(sid, externaltype, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a File Explorer Object by a given ROOM
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id ROOM Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoom(sid: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileExplorerObject>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).getRoom(sid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get list of FileItemDTO by parent
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the parent folder id
         * @param {number} parent the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomByParent(sid: string, id: number, parent: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FileItemDTO>>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).getRoomByParent(sid, id, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * move a file or folder
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id current file or folder id to be moved
         * @param {number} roomid room this file need to be moved
         * @param {number} parentid new parent folder id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async move(sid: string, id: number, roomid: number, parentid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileItemDTO>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).move(sid, id, roomid, parentid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * update a file or folder name
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id file or folder id
         * @param {string} name new file or folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rename(sid: string, id: number, name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileItemDTO>> {
            const localVarAxiosArgs = await FileServiceApiAxiosParamCreator(configuration).rename(sid, id, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * FileServiceApi - factory interface
 * @export
 */
export const FileServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * to add a folder to the private drive, set parentId = 0 and isOwner to 1/true and  externalUserId/externalUserType to a valid USER
         * @param {string} externalId 
         * @param {string} externalType 
         * @param {number} groupId 
         * @param {string} hash 
         * @param {number} height 
         * @param {number} id 
         * @param {string} name 
         * @param {number} ownerId 
         * @param {number} parentId 
         * @param {number} roomId 
         * @param {number} size 
         * @param {string} type 
         * @param {number} width 
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add(externalId: string, externalType: string, groupId: number, hash: string, height: number, id: number, name: string, ownerId: number, parentId: number, roomId: number, size: number, type: string, width: number, sid: string, options?: any): AxiosPromise<FileItemDTO> {
            return FileServiceApiFp(configuration).add(externalId, externalType, groupId, hash, height, id, name, ownerId, parentId, roomId, size, type, width, sid, options).then((request) => request(axios, basePath));
        },
        /**
         * deletes files or folders based on it id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the id of the file or folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(sid: string, id: number, options?: any): AxiosPromise<ServiceResult> {
            return FileServiceApiFp(configuration).delete1(sid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * deletes a file by its external Id and type
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} externaltype the externalType
         * @param {string} externalid the id of the file or folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExternal(sid: string, externaltype: string, externalid: string, options?: any): AxiosPromise<ServiceResult> {
            return FileServiceApiFp(configuration).deleteExternal(sid, externaltype, externalid, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all files by external type
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} externaltype External type for file listing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllExternal(sid: string, externaltype: string, options?: any): AxiosPromise<Array<FileItemDTO>> {
            return FileServiceApiFp(configuration).getAllExternal(sid, externaltype, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a File Explorer Object by a given ROOM
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id ROOM Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoom(sid: string, id: number, options?: any): AxiosPromise<FileExplorerObject> {
            return FileServiceApiFp(configuration).getRoom(sid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of FileItemDTO by parent
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the parent folder id
         * @param {number} parent the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomByParent(sid: string, id: number, parent: number, options?: any): AxiosPromise<Array<FileItemDTO>> {
            return FileServiceApiFp(configuration).getRoomByParent(sid, id, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * move a file or folder
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id current file or folder id to be moved
         * @param {number} roomid room this file need to be moved
         * @param {number} parentid new parent folder id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        move(sid: string, id: number, roomid: number, parentid: number, options?: any): AxiosPromise<FileItemDTO> {
            return FileServiceApiFp(configuration).move(sid, id, roomid, parentid, options).then((request) => request(axios, basePath));
        },
        /**
         * update a file or folder name
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id file or folder id
         * @param {string} name new file or folder name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rename(sid: string, id: number, name: string, options?: any): AxiosPromise<FileItemDTO> {
            return FileServiceApiFp(configuration).rename(sid, id, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileServiceApi - object-oriented interface
 * @export
 * @class FileServiceApi
 * @extends {BaseAPI}
 */
export class FileServiceApi extends BaseAPI {
    /**
     * to add a folder to the private drive, set parentId = 0 and isOwner to 1/true and  externalUserId/externalUserType to a valid USER
     * @param {string} externalId 
     * @param {string} externalType 
     * @param {number} groupId 
     * @param {string} hash 
     * @param {number} height 
     * @param {number} id 
     * @param {string} name 
     * @param {number} ownerId 
     * @param {number} parentId 
     * @param {number} roomId 
     * @param {number} size 
     * @param {string} type 
     * @param {number} width 
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public add(externalId: string, externalType: string, groupId: number, hash: string, height: number, id: number, name: string, ownerId: number, parentId: number, roomId: number, size: number, type: string, width: number, sid: string, options?: any) {
        return FileServiceApiFp(this.configuration).add(externalId, externalType, groupId, hash, height, id, name, ownerId, parentId, roomId, size, type, width, sid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * deletes files or folders based on it id
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id the id of the file or folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public delete1(sid: string, id: number, options?: any) {
        return FileServiceApiFp(this.configuration).delete1(sid, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * deletes a file by its external Id and type
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {string} externaltype the externalType
     * @param {string} externalid the id of the file or folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public deleteExternal(sid: string, externaltype: string, externalid: string, options?: any) {
        return FileServiceApiFp(this.configuration).deleteExternal(sid, externaltype, externalid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all files by external type
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {string} externaltype External type for file listing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public getAllExternal(sid: string, externaltype: string, options?: any) {
        return FileServiceApiFp(this.configuration).getAllExternal(sid, externaltype, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a File Explorer Object by a given ROOM
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id ROOM Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public getRoom(sid: string, id: number, options?: any) {
        return FileServiceApiFp(this.configuration).getRoom(sid, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get list of FileItemDTO by parent
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id the parent folder id
     * @param {number} parent the room id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public getRoomByParent(sid: string, id: number, parent: number, options?: any) {
        return FileServiceApiFp(this.configuration).getRoomByParent(sid, id, parent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * move a file or folder
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id current file or folder id to be moved
     * @param {number} roomid room this file need to be moved
     * @param {number} parentid new parent folder id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public move(sid: string, id: number, roomid: number, parentid: number, options?: any) {
        return FileServiceApiFp(this.configuration).move(sid, id, roomid, parentid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a file or folder name
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id file or folder id
     * @param {string} name new file or folder name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileServiceApi
     */
    public rename(sid: string, id: number, name: string, options?: any) {
        return FileServiceApiFp(this.configuration).rename(sid, id, name, options).then((request) => request(this.axios, this.basePath));
    }
}
