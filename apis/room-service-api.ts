/* tslint:disable */
/* eslint-disable */
/**
 * Apache OpenMeetings API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 7.0.0-SNAPSHOT
 * Contact: dev@openmeetings.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InvitationDTO } from '../models';
import { RoomBody } from '../models';
import { RoomDTO } from '../models';
import { ServiceResult } from '../models';
import { UserDTO } from '../models';
/**
 * RoomServiceApi - axios parameter creator
 * @export
 */
export const RoomServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new ROOM like through the Frontend
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {RoomBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add2: async (sid: string, body?: RoomBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling add2.');
            }
            const localVarPath = `/room`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            localVarHeaderParameter['Content-Type'] = '*/*';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Method to clean room white board (all objects will be purged) - Deprecated use WbService#resetWb method instead
         * @param {number} id 
         * @param {string} [sid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanWb: async (id: number, sid?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cleanWb.');
            }
            const localVarPath = `/room/cleanwb/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Method to remotely close rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        close: async (sid: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling close.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling close.');
            }
            const localVarPath = `/room/close/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the count of users currently in the ROOM with given id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} roomid roomId id of the room to get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        count: async (sid: string, roomid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling count.');
            }
            // verify required parameter 'roomid' is not null or undefined
            if (roomid === null || roomid === undefined) {
                throw new RequiredError('roomid','Required parameter roomid was null or undefined when calling count.');
            }
            const localVarPath = `/room/count/{roomid}`
                .replace(`{${"roomid"}}`, encodeURIComponent(String(roomid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a room by its room id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id The id of the room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4: async (sid: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling delete4.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delete4.');
            }
            const localVarPath = `/room/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if a room with this exteralId + externalType does exist,  if yes it returns the room id if not, it will create the room and then  return the room id of the newly created room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} type type of the room
         * @param {string} externaltype you can specify your system-name or type of room here, for example \&quot;moodle\&quot;
         * @param {string} externalid your external room id may set here
         * @param {RoomDTO} room details of the room to be created if not found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternal1: async (sid: string, type: string, externaltype: string, externalid: string, room: RoomDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling getExternal1.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getExternal1.');
            }
            // verify required parameter 'externaltype' is not null or undefined
            if (externaltype === null || externaltype === undefined) {
                throw new RequiredError('externaltype','Required parameter externaltype was null or undefined when calling getExternal1.');
            }
            // verify required parameter 'externalid' is not null or undefined
            if (externalid === null || externalid === undefined) {
                throw new RequiredError('externalid','Required parameter externalid was null or undefined when calling getExternal1.');
            }
            // verify required parameter 'room' is not null or undefined
            if (room === null || room === undefined) {
                throw new RequiredError('room','Required parameter room was null or undefined when calling getExternal1.');
            }
            const localVarPath = `/room/{type}/{externaltype}/{externalid}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"externaltype"}}`, encodeURIComponent(String(externaltype)))
                .replace(`{${"externalid"}}`, encodeURIComponent(String(externalid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            if (room !== undefined) {
                localVarQueryParameter['room'] = room;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an Object of Type RoomsList which contains a list of  ROOM-Objects. Every ROOM-Object contains a Roomtype and all informations  about that ROOM. The List of current-users in the room is Null if you get  them via SOAP. The Roomtype can be 'conference', 'presentation' or 'interview'.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} type Type of public rooms need to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublic: async (sid: string, type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling getPublic.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling getPublic.');
            }
            const localVarPath = `/room/public/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a conference room object
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById: async (sid: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling getRoomById.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoomById.');
            }
            const localVarPath = `/room/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Method to get invitation hash with given parameters
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {InvitationDTO} invite parameters of the invitation
         * @param {boolean} sendmail flag to determine if email should be sent or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hash: async (sid: string, invite: InvitationDTO, sendmail: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling hash.');
            }
            // verify required parameter 'invite' is not null or undefined
            if (invite === null || invite === undefined) {
                throw new RequiredError('invite','Required parameter invite was null or undefined when calling hash.');
            }
            // verify required parameter 'sendmail' is not null or undefined
            if (sendmail === null || sendmail === undefined) {
                throw new RequiredError('sendmail','Required parameter sendmail was null or undefined when calling hash.');
            }
            const localVarPath = `/room/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            if (invite !== undefined) {
                localVarQueryParameter['invite'] = invite;
            }

            if (sendmail !== undefined) {
                localVarQueryParameter['sendmail'] = sendmail;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * kick external USER from given room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {string} externalType external type of USER to kick
         * @param {string} externalId external id of USER to kick
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kick: async (sid: string, id: number, externalType: string, externalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling kick.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling kick.');
            }
            // verify required parameter 'externalType' is not null or undefined
            if (externalType === null || externalType === undefined) {
                throw new RequiredError('externalType','Required parameter externalType was null or undefined when calling kick.');
            }
            // verify required parameter 'externalId' is not null or undefined
            if (externalId === null || externalId === undefined) {
                throw new RequiredError('externalId','Required parameter externalId was null or undefined when calling kick.');
            }
            const localVarPath = `/room/kick/{id}/{externalType}/{externalId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"externalType"}}`, encodeURIComponent(String(externalType)))
                .replace(`{${"externalId"}}`, encodeURIComponent(String(externalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Kick all uses of a certain room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickAll: async (sid: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling kickAll.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling kickAll.');
            }
            const localVarPath = `/room/kick/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Method to remotely open rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        open: async (sid: string, id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling open.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling open.');
            }
            const localVarPath = `/room/open/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list of users currently in the ROOM with given id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} roomid roomId id of the room to get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        users: async (sid: string, roomid: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sid' is not null or undefined
            if (sid === null || sid === undefined) {
                throw new RequiredError('sid','Required parameter sid was null or undefined when calling users.');
            }
            // verify required parameter 'roomid' is not null or undefined
            if (roomid === null || roomid === undefined) {
                throw new RequiredError('roomid','Required parameter roomid was null or undefined when calling users.');
            }
            const localVarPath = `/room/users/{roomid}`
                .replace(`{${"roomid"}}`, encodeURIComponent(String(roomid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sid !== undefined) {
                localVarQueryParameter['sid'] = sid;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomServiceApi - functional programming interface
 * @export
 */
export const RoomServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds a new ROOM like through the Frontend
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {RoomBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add2(sid: string, body?: RoomBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDTO>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).add2(sid, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Method to clean room white board (all objects will be purged) - Deprecated use WbService#resetWb method instead
         * @param {number} id 
         * @param {string} [sid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cleanWb(id: number, sid?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).cleanWb(id, sid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Method to remotely close rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async close(sid: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).close(sid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the count of users currently in the ROOM with given id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} roomid roomId id of the room to get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async count(sid: string, roomid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).count(sid, roomid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete a room by its room id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id The id of the room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete4(sid: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).delete4(sid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Checks if a room with this exteralId + externalType does exist,  if yes it returns the room id if not, it will create the room and then  return the room id of the newly created room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} type type of the room
         * @param {string} externaltype you can specify your system-name or type of room here, for example \&quot;moodle\&quot;
         * @param {string} externalid your external room id may set here
         * @param {RoomDTO} room details of the room to be created if not found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternal1(sid: string, type: string, externaltype: string, externalid: string, room: RoomDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDTO>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).getExternal1(sid, type, externaltype, externalid, room, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an Object of Type RoomsList which contains a list of  ROOM-Objects. Every ROOM-Object contains a Roomtype and all informations  about that ROOM. The List of current-users in the room is Null if you get  them via SOAP. The Roomtype can be 'conference', 'presentation' or 'interview'.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} type Type of public rooms need to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublic(sid: string, type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RoomDTO>>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).getPublic(sid, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a conference room object
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomById(sid: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoomDTO>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).getRoomById(sid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Method to get invitation hash with given parameters
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {InvitationDTO} invite parameters of the invitation
         * @param {boolean} sendmail flag to determine if email should be sent or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hash(sid: string, invite: InvitationDTO, sendmail: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).hash(sid, invite, sendmail, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * kick external USER from given room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {string} externalType external type of USER to kick
         * @param {string} externalId external id of USER to kick
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kick(sid: string, id: number, externalType: string, externalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).kick(sid, id, externalType, externalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Kick all uses of a certain room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async kickAll(sid: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).kickAll(sid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Method to remotely open rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async open(sid: string, id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceResult>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).open(sid, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns list of users currently in the ROOM with given id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} roomid roomId id of the room to get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async users(sid: string, roomid: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDTO>>> {
            const localVarAxiosArgs = await RoomServiceApiAxiosParamCreator(configuration).users(sid, roomid, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoomServiceApi - factory interface
 * @export
 */
export const RoomServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Adds a new ROOM like through the Frontend
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {RoomBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add2(sid: string, body?: RoomBody, options?: any): AxiosPromise<RoomDTO> {
            return RoomServiceApiFp(configuration).add2(sid, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Method to clean room white board (all objects will be purged) - Deprecated use WbService#resetWb method instead
         * @param {number} id 
         * @param {string} [sid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cleanWb(id: number, sid?: string, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).cleanWb(id, sid, options).then((request) => request(axios, basePath));
        },
        /**
         * Method to remotely close rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        close(sid: string, id: number, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).close(sid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the count of users currently in the ROOM with given id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} roomid roomId id of the room to get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        count(sid: string, roomid: number, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).count(sid, roomid, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a room by its room id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id The id of the room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete4(sid: string, id: number, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).delete4(sid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if a room with this exteralId + externalType does exist,  if yes it returns the room id if not, it will create the room and then  return the room id of the newly created room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} type type of the room
         * @param {string} externaltype you can specify your system-name or type of room here, for example \&quot;moodle\&quot;
         * @param {string} externalid your external room id may set here
         * @param {RoomDTO} room details of the room to be created if not found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternal1(sid: string, type: string, externaltype: string, externalid: string, room: RoomDTO, options?: any): AxiosPromise<RoomDTO> {
            return RoomServiceApiFp(configuration).getExternal1(sid, type, externaltype, externalid, room, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an Object of Type RoomsList which contains a list of  ROOM-Objects. Every ROOM-Object contains a Roomtype and all informations  about that ROOM. The List of current-users in the room is Null if you get  them via SOAP. The Roomtype can be 'conference', 'presentation' or 'interview'.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {string} type Type of public rooms need to be retrieved
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublic(sid: string, type: string, options?: any): AxiosPromise<Array<RoomDTO>> {
            return RoomServiceApiFp(configuration).getPublic(sid, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a conference room object
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById(sid: string, id: number, options?: any): AxiosPromise<RoomDTO> {
            return RoomServiceApiFp(configuration).getRoomById(sid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Method to get invitation hash with given parameters
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {InvitationDTO} invite parameters of the invitation
         * @param {boolean} sendmail flag to determine if email should be sent or not
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hash(sid: string, invite: InvitationDTO, sendmail: boolean, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).hash(sid, invite, sendmail, options).then((request) => request(axios, basePath));
        },
        /**
         * kick external USER from given room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {string} externalType external type of USER to kick
         * @param {string} externalId external id of USER to kick
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kick(sid: string, id: number, externalType: string, externalId: string, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).kick(sid, id, externalType, externalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Kick all uses of a certain room
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        kickAll(sid: string, id: number, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).kickAll(sid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Method to remotely open rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} id the room id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        open(sid: string, id: number, options?: any): AxiosPromise<ServiceResult> {
            return RoomServiceApiFp(configuration).open(sid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns list of users currently in the ROOM with given id
         * @param {string} sid The SID of the User. This SID must be marked as Loggedin
         * @param {number} roomid roomId id of the room to get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        users(sid: string, roomid: number, options?: any): AxiosPromise<Array<UserDTO>> {
            return RoomServiceApiFp(configuration).users(sid, roomid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomServiceApi - object-oriented interface
 * @export
 * @class RoomServiceApi
 * @extends {BaseAPI}
 */
export class RoomServiceApi extends BaseAPI {
    /**
     * Adds a new ROOM like through the Frontend
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {RoomBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public add2(sid: string, body?: RoomBody, options?: any) {
        return RoomServiceApiFp(this.configuration).add2(sid, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Method to clean room white board (all objects will be purged) - Deprecated use WbService#resetWb method instead
     * @param {number} id 
     * @param {string} [sid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public cleanWb(id: number, sid?: string, options?: any) {
        return RoomServiceApiFp(this.configuration).cleanWb(id, sid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Method to remotely close rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id the room id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public close(sid: string, id: number, options?: any) {
        return RoomServiceApiFp(this.configuration).close(sid, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the count of users currently in the ROOM with given id
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} roomid roomId id of the room to get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public count(sid: string, roomid: number, options?: any) {
        return RoomServiceApiFp(this.configuration).count(sid, roomid, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a room by its room id
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id The id of the room
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public delete4(sid: string, id: number, options?: any) {
        return RoomServiceApiFp(this.configuration).delete4(sid, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Checks if a room with this exteralId + externalType does exist,  if yes it returns the room id if not, it will create the room and then  return the room id of the newly created room
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {string} type type of the room
     * @param {string} externaltype you can specify your system-name or type of room here, for example \&quot;moodle\&quot;
     * @param {string} externalid your external room id may set here
     * @param {RoomDTO} room details of the room to be created if not found
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public getExternal1(sid: string, type: string, externaltype: string, externalid: string, room: RoomDTO, options?: any) {
        return RoomServiceApiFp(this.configuration).getExternal1(sid, type, externaltype, externalid, room, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an Object of Type RoomsList which contains a list of  ROOM-Objects. Every ROOM-Object contains a Roomtype and all informations  about that ROOM. The List of current-users in the room is Null if you get  them via SOAP. The Roomtype can be 'conference', 'presentation' or 'interview'.
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {string} type Type of public rooms need to be retrieved
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public getPublic(sid: string, type: string, options?: any) {
        return RoomServiceApiFp(this.configuration).getPublic(sid, type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a conference room object
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id the room id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public getRoomById(sid: string, id: number, options?: any) {
        return RoomServiceApiFp(this.configuration).getRoomById(sid, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Method to get invitation hash with given parameters
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {InvitationDTO} invite parameters of the invitation
     * @param {boolean} sendmail flag to determine if email should be sent or not
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public hash(sid: string, invite: InvitationDTO, sendmail: boolean, options?: any) {
        return RoomServiceApiFp(this.configuration).hash(sid, invite, sendmail, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * kick external USER from given room
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id the room id
     * @param {string} externalType external type of USER to kick
     * @param {string} externalId external id of USER to kick
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public kick(sid: string, id: number, externalType: string, externalId: string, options?: any) {
        return RoomServiceApiFp(this.configuration).kick(sid, id, externalType, externalId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Kick all uses of a certain room
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id the room id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public kickAll(sid: string, id: number, options?: any) {
        return RoomServiceApiFp(this.configuration).kickAll(sid, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Method to remotely open rooms. If a room is closed all users  inside the room and all users that try to enter it will be redirected to  the redirectURL that is defined in the ROOM-Object.
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} id the room id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public open(sid: string, id: number, options?: any) {
        return RoomServiceApiFp(this.configuration).open(sid, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns list of users currently in the ROOM with given id
     * @param {string} sid The SID of the User. This SID must be marked as Loggedin
     * @param {number} roomid roomId id of the room to get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomServiceApi
     */
    public users(sid: string, roomid: number, options?: any) {
        return RoomServiceApiFp(this.configuration).users(sid, roomid, options).then((request) => request(this.axios, this.basePath));
    }
}
